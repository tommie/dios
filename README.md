# DiOS - a dispatching OS for Microchip PIC14/16 microcontrollers

This is a tiny operating system for PIC microcontrollers.
The point of it is to be able to write modular and efficient assembly code.

## Background

Writing PIC assembly is tedious because of the limited instruction set and accumulator architectures.
At the same time, there are no great free C compilers, most likely because the PIC architecture makes it terrible.
But sometimes fun and cheap.

While building a firmware replacement for my Atten AT860D hotair soldering station, I wanted something that could help me structure the code better.

## Status

This is **alpha** software.

## Goals

- Small.
- Easy to do simple stuff, possible to do complex things.
- Help with coordinating independent modules, but don't try to solve all PIC problems.
- Make initialization of registers more efficient: only one write per register.
- Handle going to sleep if there is nothing to do.
- Only test a condition once per main loop (e.g. checking the T0IF interrupt flag.)
- Avoid brute-force code that keeps retesting the same condition over and over; check and post an event once.
- Support priorities for event queues.
- Bridge the gap between running ISR code and handling IRQs in the main loop.
  Changing back and forth should be easy.
- Be flexible within these goals.

## Features

- Define independent modules that can hook into various things like idle loop, specific IRQs, etc.
- Define constants that are merged with bit operations (and, or, xor, add, subtract) across modules.
- Define hooks for individual interrupts, for modules to handle.
- Define wake-up sources, allowing the CPU to sleep when there is nothing to do.
- Define event queues, with priorities, to post and handle events independently in modules.
- Define custom hooks, e.g. to use when synchronous pre-processing is easier than events.

## Usage

You write module files, which are included in the main file generated by `diosgen`.
The main assembly file is configured using a special DiOS assembly file as input to the generator.

### Generating Code

Here is an example invocation to generate a main file given a DiOS Configuration file called `mycode.asm`:

```console
$ diosgen.py -o mycode.dios.asm mycode.asm
$ gpasm      -p16f887 --mpasm-compatible -c mycode.dios.asm
$ gplink     --mplink-compatible mycode.dios.o
```

### Modules

Each module is a normal `.inc` PIC assembly file with the additional constraint that all code is structured in `ifdef` sections:

```asm
    ifdef     diosh_init
    movlw     0
    banksel   TRISA
    movwf     TRISA
    endif     ; diosh_init

    ifdef     diosh_event_IDLE_QUEUE_IRQ_EVENT
    movlw     1
    banksel   PORTA
    xorwf     PORTA, F
    endif     ; diosh_event_IDLE_QUEUE_IRQ_EVENT

    ifdef     diosh_irq
    diospost  IRQ_EVENT
    endif     ; diosh_irq

    ifdef     diosh_udata
myvar res     1
    endif     ; diosh_udata

    ifdef     diosh_code
myfunc:
    retlw     42
    endif     ; diosh_code
```

The module file is included multiple times, at various places in the generated main file.

### DiOS Configuration File

The configuration file lists modules, and coordination primitives:

```asm
    ;; A marker that this is a DiOS file.
    dios

    ;; Arbitrary include files to be added to the main file, usually the processor
    ;; and board definitions.
    include "p16f887.inc"

    ;; Listed in dependency order: later modules use earlier modules.
    module  "adc.inc"
    module  "timer.inc"

    ;; Creates the "trise_init" constant, which is defined as
    ;; "adc_trise_init | timer_trise_init" (treating missing ones as zero.)
    const   trise_init, or

    ;; Defines an event queue that runs in the idle loop. It has one event.
    ;;
    ;; Posting to it uses the macro `diospost IDLE_QUEUE_IRQ_EVENT`.
    ;; Handle it using `ifdef diosh_event_IDLE_QUEUE_IRQ_EVENT`.
    evqueue IDLE_QUEUE, idle
    event   IRQ_EVENT

    ;; Defines a second event queue that runs in the idle loop, having lower
    ;; priority than IDLE_QUEUE.
    evqueue IDLE_QUEUE_LOW, idle
    event   SOME_EVENT

    ;; Defines an event queue that is not automatically processed. Code can use
    ;; the process_custom_queue macro to process it. It shares the SOME_EVENT
    ;; wth IDLE_QUEUE_LOW, so posting that event adds it to both queues.
    evqueue CUSTOM_QUEUE
    event   SOME_EVENT

    ;; Creates a phase called irq_timer0 for the T0IF interrupt flag.
    ;;
    ;; Handle it using `ifdef diosh_irq_timer0`.
    irq     irq_timer0, INTCON, T0IF

    ;; Defines a custom hook that can be invoked by calling the
    ;; `phase_preprocess` function.
    phase   preprocess

    ;; Enables going to sleep if there is nothing to do and both INTE and GIE are set.
    wake    INTCON, INTE
```

### Phases

Phases are similar to tasks in other RTOSes.
There are a few built-in phases:

| Phase | Description |
|-------|-------------|
| init  | Issued on reset.
| idle  | Issued continuously in the idle loop.
| irq   | Issued inside the ISR.
| sleep | If sleep is enabled, issued before sleep.

More phases can be created using the `irq` and `phase` directives.
The IRQ phases are automatically invoked inside the ISR, and the corresponding flag is cleared before execution.
Custom phases are not executed unless you call them.

Every phase has two possible handlers: the main and the post.
The main handler uses `ifdef diosh_$name`.
The post-handler uess `ifdef diosph_$name` and is executed in reverse module order.

In the `irq` phase, the post-handler is executed after all specific IRQ handlers.
In the `sleep` phase, the post-handler is executed on wake-up.
Using post-handlers is likely not very useful for `init` and `idle`.

### Additional Code and Data

Similar to the phases, there are hooks available for definition various sections:

| Hook      | Description |
|-----------|-------------|
| udata     | Uninitialized data
| udata_shr | Uninitialized data in the non-banked space
| idata     | Initialized data
| eedata    | Data EEPROM definitions
| code      | For utility functions

There are no post-handlers, so `ifdef diosh_udata` is the only way to add uninitialized data.

### Constants

A pet-peeve is having to write multiple times to the same register in initialization in modular code:

```asm
    ; Module a.inc
init:
    bcf TRISA, 0

    ; Module b.inc
init:
    bcf TRISA, 3
```

This seems inefficient, since the compiler should be able to merge these and issue a single move.

The `const` directive provides a way to do that:

```asm
    ; DiOS Config
    dios
    module  "a.inc"
    module  "b.inc"
    module  "port.inc"
    const   trisa_init, and  ; The default values should be 1 (inputs), so using and.

    ; Module a.inc
a_trisa_init    ~(1 << 0)

    ; Module b.inc
b_trisa_init    ~(1 << 3)

    ; Module port.inc
    ifdef       diosh_init
    movlw       trisa
    banksel     TRISA
    movwf       TRISA
    endif       ; diosh_init
```

These operators are defined:

| Operator | Empty Value |
|----------|-------------|
| `and`    | 0xF...F
| `or`     | 0
| `xor`    | 0
| `add`    | 0
| `sub`    | 0

The empty value is used if no module defines a value.

### Events and Queues

Since PIC devices are small, we only support event flags.
It is up to you to store any additional state that is useful to the event handler(s).

Events are independent of queues in that their names are global, and they can be posted to multiple queues.

```asm
    ; DiOS Config
    dios
    module      "a.inc"
    evqueue     IDLE_QUEUE, idle
    event       TIMER_EVENT

    evqueue     IRQ_QUEUE, irq
    event       TIMER_EVENT

    ; Module a.inc
    ifdef       diosh_event_IDLE_QUEUE_TIMER_EVENT
    banksel     PORTA
    bsf         PORTA, 0
    endif       ; diosh_event_IDLE_QUEUE_TIMER_EVENT

    ifdef       diosh_event_IRQ_QUEUE_TIMER_EVENT
    banksel     PORTA
    bcf         PORTA, 0
    endif       ; diosh_event_IRQ_QUEUE_TIMER_EVENT
```

Posting the `TIMER_EVENT` causes it to immediately set pin A0, but when the next IRQ happens, it the pin is cleared:

```asm
    diospost    TIMER_EVENT
```

#### Priorities

Sometimes, it's useful to layer event handlers so that some events are always processed before others.
Within a queue, there are no priorities: checking for events is always sequential and never aborted.
However, if one phase has multiple queues, they create priority layers.
If there were any events handled in a queue, processing starts from the top of the phase again, instead of carrying on to the next queue.
This is a hard priority, and may (as always) cause starvation.
Since the phase starts over, feeding a watchdog timer in the *post-handler* (and not the main handler) of the phase will let you know if starvation is happening.

It doesn't make sense to handle the same event at multiple priority layers, so `diosgen` fails if you make that mistake.

### IRQ

Sometimes, two independent modules want to handle the same IRQ.
Having to check the interrupt flag twice is not great for performance or code size.
Structuring code better can easily avoid that.

Using the `irq` directive, we can create new phases for individual interrupts.
Before running your handler, the flag is cleared.
You will likely do some small amount of I/O and store a value, or post an event.

```asm
    ; DiOS Config
    dios
    module      "a.inc"
    irq         irq_t0, INTCON, T0IF
    ; Event definitions elided.

    ; Module a.inc
    ifdef       diosh_irq_t0
    diospost    T0_EVENT
    endif       ; diosh_irq_t0
```

To make it more obvious that the code runs inside an ISR (and what that means about saving context,) the phase name must start with `irq_`.

Since these are phases, you can attach event queues to them, if that makes sense in your case:

```asm
    ; DiOS Config
    dios
    module      "a.inc"
    irq         irq_t0, INTCON, T0IF
    evqueue     T0_QUEUE, irq_t0
    event       FROM_IDLE

    ; Module a.inc
    ifdef       diosh_idle
    diospost    FROM_IDLE
    endif       ; diosh_idle

    ifdef       diosh_event_T0_QUEUE_FROM_IDLE
    movlw       1
    banksel     PORTA
    xorwf       PORTA, F
    endif       ; diosh_event_T0_QUEUE_FROM_IDLE
```

This essentially says "wait for both FROM_IDLE and T0IF, then toggle pin A0."

### Sleep and Wake-Up Sources

If you do nothing special, the idle loop will continuously run forever.
This leads to higher energy consumption than needed.
Ideally, we'd stop processing when there is nothing to do.
This requires us to know when to resume processing.

Using the `wake` directive, you can tell DiOS that some interrupt source can wake the CPU from sleep:

```asm
    ; DiOS Config
    dios
    module      "a.inc"
    wake        INTCON, INTE  ; Note it's the enable-flag, not the interrupt-flag.

    ; Module a.inc
    ifdef       diosh_sleep
    banksel     PORTA
    bsf         PORTA, 0
    endif       ; diosh_sleep

    ifdef       diosph_sleep
    banksel     PORTA
    bcf         PORTA, 0
    endif       ; diosph_sleep
```

This enables sleep code that runs at the end of each idle loop iteration, putting the CPU to sleep if there is nothing to do.
Before going to sleep, DiOS checks that at least one wake-up source is enabled (including `GIE`).

Note that DiOS does not know about multiplexing hierarchies like the `PEIE` bit, so ensure that's always enabled.

As an optimization, you can use `wake always` to enable sleep, but ignore the wake-up source checks.
DiOS will assume that you always have some source enabled.

## Usage Patterns

### Using Macros For Local Names

Modules share symbol namespace, so when using labels, it may be useful to wrap code in macros:

```asm
    ; Module a.inc
    ifdef       diosh_idle
t0idle_handler  macro
    local       mend
    ....
    goto        mend
    ...
mend:
    endm
    t0idle_handler
    endif       ; diosh_idle
```

### Abstract Modules

Some modules are building blocks that shouldn't do anything unless instantiated.
Or, perhaps there can be any number of instances.
E.g. an AES or PID control software implementation.

In this case, you likely want to make use of MPASM's `#v(expr)` expansion to create unique names for variables:

```asm
                    ; Module pid.inc
                    ifdef   diosh_udata
pid_udata           macro   index, Ki
pid_ki#v(index)     equ     Ki
pid_err#v(index)    res     1
pid_acc#v(index)    res     1
                    endm
                    endif   ; diosh_udata

                    ifdef   diosh_code
pid_update          macro   index, errf
                    banksel errf
                    movf    errf, W
                    movwf   pid_err#v(index)
                    movlw   pid_ki#v(index)
                    ; ...
                    endm
                    endif   ; diosh_code


                ; Module tempcontrol.inc
                ifdef       diosh_udata
tempcontrol_pid equ         0   ; Must be unique; could use a CBLOCK.
                pid_udata   tempcontrol_pid, 42
                endif       ; diosh_udata

                ifdef       diosh_idle
                pid_update  tempcontrol_pid, PORTA
                endif       ; diosh_idle
```

Note that the index integers don't need to be consequtive or start at zero.
They're just used to generate unique variable names.

### IRQ Context Saving

DiOS only saves enough context for its own purposes: `W`, `STATUS`, and `PCLATH`.
If you need to save other variables, use the `irq` phase main and post handlers:

```asm
    ; Module a.inc
    ifdef       diosh_udata_shr
save_option res 1
    endif       ; diosh_udata_shr

    ifdef       diosh_irq
    banksel     OPTION
    movf        OPTION, W
    movwf       save_option
    endif       ; diosh_irq

    ifdef       diosph_irq
    movf        save_option, W
    banksel     OPTION
    movwf       OPTION
    endif       ; diosph_irq
```

### Handling IRQs in the Main Loop

Sometimes IRQs shouldn't block execution of other IRQs, so you want to handle them in the main loop.
Using a conditional in an idle handler, and posting a dedicated event would make sense.
However, that is less efficient than running handler code directly in the conditional:

```asm
    ; DiOS Config
    dios
    module      "t0idle.inc"
    phase       idleirq_t0

    ; Module t0idle.inc
    ifdef       diosh_idle
    pagesel     t0idle_end
    btfss       INTCON, 0
    goto        t0idle_end
    call        phase_idleirq_t0
t0idle_end:
    endif       ; diosh_idle
```

Now any module can handle `diosh_phase_idleirq_t0` and end up directly after the conditional.

Additionally, just like with IRQ phases mentioned above, you can attach event queues to `idleirq_t0` to only handle some events whenever `t0` triggers.

### Watchdog Timer

The point of an event-based RTOS is that the idle loop is always being executed, so there's an obvious place for feeding the WDT.
The best place for a WDT module is the idle post-handler.
This ensures that starvation, when there are multiple idle queues, cause a WDT reset.

```asm
    ; Module wdt.inc
    ifdef   diosh_init
    movlw   0x0A << WDTPS0      ; 1:32768, or ~1 s
    banksel WDTCON
    movwf   WDTCON
    endif   ; diosh_init

    ifdef   diosph_idle
    clrwdt
    endif   ; diosph_idle
```

If starvation is acceptable, but other hangups are not, use the main idle handler: `diosh_idle`.
Of course, if there are other phases that may take a long time, you can add watchdog handlers for them too.

### Reset Cause Handler

If you want to catch WDT resets, you could create an event for it:

```asm
    ; DiOS Config
    dios
    module      "wdt.inc"

    evqueue     IDLE_QUEUE, idle
    event       WDT_RESET_EVENT

    ; Module wdt.inc
    ifdef       diosh_init
    ; ... WDTCon initialization if required ...

    pagesel     wdt_reset_end
    btfss       STATUS, NOT_TO
    goto        wdt_reset_end
    diospost    WDT_RESET_EVENT
wdt_reset_end:
    endif       ; diosh_init

    ifdef       diosph_idle
    clrwdt
    endif       ; diosph_idle
```

This is using an event rather than a phase, to avoid running "main" code inside the "init" phase, when not everything might be initialized.
Your use-case might be different, but there is usually nothing urgent about handling the reset condition, once the `STATUS` register has been saved.

## Internals

### Event Queues

There are three sizes of queues:

- **Tiny** queues have at most two events.
  They only ever check each bit separately; the naive case.
- **Medium** queues have at most 16 events.
  Before checking individual bits, they check if the entire byte is non-zero.
- **Large** queues are the rest.
  They set a queue-wide flag on posting, and only check the individual bytes and bits if that global flag is set.

There should be no visible difference to the user.

## Ideas

- It would be nice to use macros instead of `ifdef`, so all handler code uses local names.
  Then we'd include all modules once, and use well-known names instead.
  Before building the code generator, the `ifdef` approach required less maintenance, so that's where we are.
- Timers would be useful in general, to share the few hardware timers more easily.
  This is similar to event counter expressions, but would be able to disable the hardware when it's not needed.
- gpsim could be used for automatic testing.
  Remember to disable WDT!
- Event expressions: building meta-events to say "post X if A and then B or (C and D in any order) are posted".
  Not entirely sure how useful that would be on its own.
  - "post X if A has been posted 10 times" would be useful for timers
  - "post X if A has been posted 10 times and not B" would be useful to debouncers
- Continuations: implementing cooperative multitasking by allowing "waiting" on one or more events, like POSIX `select(2)`.
  For PIC-sized code, is there any benefit compared to modular event handlers?
